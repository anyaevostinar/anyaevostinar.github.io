---
layout: page
title: Quizzes Overview
permalink: /classes/201-s24/quizzes-overview
---

## Quiz Structure
As discussed in the [syllabus](syllabus), the quizzes in this class are meant to assess your proficiency on a specific set of learning objectives.
Each quiz will have a posted set of learning objectives that you can demonstrate proficiency/mastery in for that quiz, and each learning objective will appear on at least 2 quizzes. Some of the objectives have notes on what specifically is required for proficiency and mastery.

## Quiz Learning Objectives
The learning objectives that will ultimately all be assessed via quizzes are:
1. Defining variables with appropriate type in Java
    a. Proficiency - basic types, M - Collections with generics
2. Writing loops (definite and indefinite) in Java
    a. Proficiency - basic loops, M - Nested loops
3. Writing conditional statements in Java
    a. Proficiency - two part, M - three part (including else if or nested)
4. Defining methods in Java
    a. Proficiency - method without parameters/return value, M - parameters and return value
5. Instantiating and using objects in Java
    a. Proficiency - using without parameters/return value, M - using method with parameters and return value
6. Using interfaces
    a. Proficiency - implement a specified interface, M - define your own interface
7. Using inheritance
    a. Proficiency - simple subclass, M - use call to super to build on super's method
8. Using linked lists
9. Explaining time complexity of linked list operations
    a. Proficiency - define Big-O of specified operation, M - demonstrate how you get that Big-O
10. Using stacks
11. Explaining time complexity of stack operations
    a. Proficiency - define Big-O of specified operation, M - demonstrate how you get that Big-O
12. Using queues
13. Explaining time complexity of queue operations
    a. Proficiency - define Big-O of specified operation, M - demonstrate how you get that Big-O
14. Explaining quicksort
15. Explaining time complexity of quicksort
    a. Proficiency - define Big-O of best and worst case, M - explain how you get those Big-O
16. Using recursion
17. Using balanced search trees
18. Using heaps
19. Explaining time complexity of heapsort
    a. Proficiency - define Big-O in worst case, M - demonstrate how you get that Big-O
20. Demonstrating breadth-first search
    a. Proficiency - indicate first level of BFS, M - demonstrate full BFS
21. Explaining time complexity of breadth-first search
    a. Proficiency - define Big-O in worst case in terms of just V, M - demonstrate how you get that Big-O
22. Demonstrating depth-first search
    a. Proficiency - indicate first sequence of DFS, M - demonstrate full DFS
23. Demonstrating hash tables
24. Explaining time complexity of hashing
    a. Proficiency - define Big-O in worst case, M - explain how you get that Big-O

You can see how you are doing on each of these on Moodle under the "Grades" tab.